---
id: f867815e-aefd-415c-a46f-33b353b7c9b7
title: Adaptive userspace spinlocks with rseq
author: Igalia
tags:
  - c
  - linux
  - programing
  - resq
  - youtube
date: 2024-08-28 00:36:33
date_published: 2024-03-11 02:00:00
words_count: 4069
state: INBOX
---

# Adaptive userspace spinlocks with rseq by Igalia
## Table of contents
```dataviewjs 
dv.view('/Bins/js/toc', 1) 
```


## description
>[!summary] 
> Implementing efficient spinlocks in userspace is not possible yet in Linux,
even after years of different approaches and proposed solutions.The main gap to
achieve it is the lack of ABI providing an easy and low-overhead way to check
if the current lock holder is running or not.

In this session, we are going to present the problem, and to propose a solution
for it using the restartable sequences infrastructure as means to expose the
thread state to userspace in a cheap way, without requiring system calls.

RFC:
https://lore.kernel.org/lkml/20230529191416.53955-1-mathieu.desnoyers@efficios.com/

Slides available at: https://www.slideshare.net/igalia/userspace-adaptive-spinlocks-with-rseq


(c) Linux Plumbers Conference 2023
15-15 Nov
Omni Richmond Hotel, Richmond, VA (US)
https://lpc.events/event/17/page/198-lpc-2023-overview


# content
```dataviewjs 
dv.view('/Bins/js/remove_html',  ["# content",  "# links"] ) 
```
<DIV id="readability-content"><DIV data-omnivore-anchor-idx="1" class="page" id="readability-page-1"><div data-omnivore-anchor-idx="2">
        <article data-omnivore-anchor-idx="3" id="_omnivore_youtube">
          <iframe data-omnivore-anchor-idx="4" id="_omnivore_youtube_video" width="619.4690265486726" height="350" src="https://www.youtube.com/embed/hRV8sW6_kDc" title="Adaptive userspace spinlocks with rseq" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
          <p data-omnivore-anchor-idx="5"><a data-omnivore-anchor-idx="6" href="https://www.youtube.com/watch?v=hRV8sW6_kDc" target="_blank">Adaptive userspace spinlocks with rseq</a></p>
          
          
        <div data-omnivore-anchor-idx="7" class="_omnivore_youtube_transcript"><pre data-omnivore-anchor-idx="8"><code data-omnivore-anchor-idx="9" class="hljs language-applescript language-routeros">Okay, hello everyone. I am Andrea Fromal, <span data-omnivore-anchor-idx="10" class="hljs-keyword">and</span> here <span data-omnivore-anchor-idx="11" class="hljs-keyword">is</span> Matthew <span data-omnivore-anchor-idx="12" class="hljs-keyword">from</span> official OS. We're here <span data-omnivore-anchor-idx="13" class="hljs-keyword">to</span> talk <span data-omnivore-anchor-idx="14" class="hljs-keyword">about</span> adaptive spin locks <span data-omnivore-anchor-idx="15" class="hljs-keyword">in</span> user <span data-omnivore-anchor-idx="16" class="hljs-literal">space</span> using RAC. 

So, people have been trying <span data-omnivore-anchor-idx="17" class="hljs-keyword">to</span> have adaptive spin locks <span data-omnivore-anchor-idx="18" class="hljs-keyword">in</span> user <span data-omnivore-anchor-idx="19" class="hljs-literal">space</span> <span data-omnivore-anchor-idx="20" class="hljs-keyword">for</span> a long <span data-omnivore-anchor-idx="21" class="hljs-built_in">time</span>, <span data-omnivore-anchor-idx="22" class="hljs-keyword">and</span> we are trying <span data-omnivore-anchor-idx="23" class="hljs-keyword">to</span> solve this again. Basically, <span data-omnivore-anchor-idx="24" class="hljs-keyword">the</span> use case <span data-omnivore-anchor-idx="25" class="hljs-keyword">behind</span> <span data-omnivore-anchor-idx="26" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="27" class="hljs-keyword">is</span> calling mutex lock—a container mutex lock. We eventually call fex <span data-omnivore-anchor-idx="28" class="hljs-keyword">that</span> requires a context switch, <span data-omnivore-anchor-idx="29" class="hljs-keyword">and</span> context switches can be way more expensive than <span data-omnivore-anchor-idx="30" class="hljs-keyword">the</span> critical section itself. This can create kind <span data-omnivore-anchor-idx="31" class="hljs-keyword">of</span> a micro contention, so you're wasting a lot <span data-omnivore-anchor-idx="32" class="hljs-keyword">of</span> <span data-omnivore-anchor-idx="33" class="hljs-built_in">time</span> going <span data-omnivore-anchor-idx="34" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="35" class="hljs-keyword">the</span> kernel <span data-omnivore-anchor-idx="36" class="hljs-keyword">instead of</span> getting <span data-omnivore-anchor-idx="37" class="hljs-keyword">the</span> lock.

Because <span data-omnivore-anchor-idx="38" class="hljs-keyword">of</span> <span data-omnivore-anchor-idx="39" class="hljs-keyword">that</span>, <span data-omnivore-anchor-idx="40" class="hljs-keyword">some</span> apps, like Postgres, have a complete user <span data-omnivore-anchor-idx="41" class="hljs-literal">space</span> lock implementation <span data-omnivore-anchor-idx="42" class="hljs-keyword">to</span> avoid any C calls. What we want <span data-omnivore-anchor-idx="43" class="hljs-keyword">to</span> do <span data-omnivore-anchor-idx="44" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="45" class="hljs-keyword">to</span> allow user <span data-omnivore-anchor-idx="46" class="hljs-literal">space</span> <span data-omnivore-anchor-idx="47" class="hljs-keyword">to</span> correctly spin. A similar use case <span data-omnivore-anchor-idx="48" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="49" class="hljs-keyword">that</span> RT mutexes <span data-omnivore-anchor-idx="50" class="hljs-keyword">on</span> <span data-omnivore-anchor-idx="51" class="hljs-keyword">the</span> kernel side use adaptive spin locks, <span data-omnivore-anchor-idx="52" class="hljs-keyword">and</span> this has been proven <span data-omnivore-anchor-idx="53" class="hljs-keyword">to</span> be a huge performance improvement.

So, <span data-omnivore-anchor-idx="54" class="hljs-keyword">the</span> challenge here <span data-omnivore-anchor-idx="55" class="hljs-keyword">is</span> basically how <span data-omnivore-anchor-idx="56" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="57" class="hljs-keyword">tell</span> <span data-omnivore-anchor-idx="58" class="hljs-keyword">if</span> a user-based thread <span data-omnivore-anchor-idx="59" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="60" class="hljs-built_in">running</span> <span data-omnivore-anchor-idx="61" class="hljs-keyword">or</span> <span data-omnivore-anchor-idx="62" class="hljs-keyword">not</span> because you should only spin <span data-omnivore-anchor-idx="63" class="hljs-keyword">if</span> <span data-omnivore-anchor-idx="64" class="hljs-keyword">the</span> lock owner <span data-omnivore-anchor-idx="65" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="66" class="hljs-built_in">running</span>. We need <span data-omnivore-anchor-idx="67" class="hljs-keyword">to</span> wait <span data-omnivore-anchor-idx="68" class="hljs-keyword">to</span> do <span data-omnivore-anchor-idx="69" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="70" class="hljs-keyword">in</span> a very fast way <span data-omnivore-anchor-idx="71" class="hljs-keyword">without</span> any C calls, <span data-omnivore-anchor-idx="72" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="73" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="74" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="75" class="hljs-keyword">where</span> our RAC comes <span data-omnivore-anchor-idx="76" class="hljs-keyword">in</span>. 

Our code <span data-omnivore-anchor-idx="77" class="hljs-keyword">is</span> already integrated <span data-omnivore-anchor-idx="78" class="hljs-keyword">with</span> <span data-omnivore-anchor-idx="79" class="hljs-keyword">the</span> task scheduler <span data-omnivore-anchor-idx="80" class="hljs-keyword">and</span> has a fast UAPI. You don’t need any C calls; you can just poke <span data-omnivore-anchor-idx="81" class="hljs-keyword">the</span> shared thread memory, <span data-omnivore-anchor-idx="82" class="hljs-keyword">the</span> memory <span data-omnivore-anchor-idx="83" class="hljs-keyword">of</span> <span data-omnivore-anchor-idx="84" class="hljs-keyword">the</span> thread <span data-omnivore-anchor-idx="85" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="86" class="hljs-keyword">is</span> shared <span data-omnivore-anchor-idx="87" class="hljs-keyword">between</span> <span data-omnivore-anchor-idx="88" class="hljs-keyword">the</span> kernel <span data-omnivore-anchor-idx="89" class="hljs-keyword">and</span> user <span data-omnivore-anchor-idx="90" class="hljs-literal">space</span>. It’s just a matter <span data-omnivore-anchor-idx="91" class="hljs-keyword">of</span> reading a structure, <span data-omnivore-anchor-idx="92" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="93" class="hljs-keyword">in</span> a similar fashion, RAC was used <span data-omnivore-anchor-idx="94" class="hljs-keyword">for</span> <span data-omnivore-anchor-idx="95" class="hljs-keyword">get</span> CPU. We are seeing a lot <span data-omnivore-anchor-idx="96" class="hljs-keyword">of</span> new use cases <span data-omnivore-anchor-idx="97" class="hljs-keyword">for</span> RAC <span data-omnivore-anchor-idx="98" class="hljs-keyword">that</span> involve new ways <span data-omnivore-anchor-idx="99" class="hljs-keyword">for</span> user <span data-omnivore-anchor-idx="100" class="hljs-literal">space</span> <span data-omnivore-anchor-idx="101" class="hljs-keyword">to</span> talk <span data-omnivore-anchor-idx="102" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="103" class="hljs-keyword">the</span> kernel <span data-omnivore-anchor-idx="104" class="hljs-keyword">and</span> ask questions <span data-omnivore-anchor-idx="105" class="hljs-keyword">about</span> <span data-omnivore-anchor-idx="106" class="hljs-keyword">the</span> task scheduler. 

The idea here <span data-omnivore-anchor-idx="107" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="108" class="hljs-keyword">to</span> have a new field <span data-omnivore-anchor-idx="109" class="hljs-keyword">for</span> RAC called <span data-omnivore-anchor-idx="110" class="hljs-keyword">the</span> `sched_state` field, which <span data-omnivore-anchor-idx="111" class="hljs-keyword">is</span> updated <span data-omnivore-anchor-idx="112" class="hljs-keyword">by</span> <span data-omnivore-anchor-idx="113" class="hljs-keyword">the</span> kernel when <span data-omnivore-anchor-idx="114" class="hljs-keyword">the</span> process <span data-omnivore-anchor-idx="115" class="hljs-keyword">is</span> scheduled out <span data-omnivore-anchor-idx="116" class="hljs-keyword">or</span> <span data-omnivore-anchor-idx="117" class="hljs-keyword">in</span>. That way, you have a field <span data-omnivore-anchor-idx="118" class="hljs-keyword">in</span> user <span data-omnivore-anchor-idx="119" class="hljs-literal">space</span> <span data-omnivore-anchor-idx="120" class="hljs-keyword">that</span> tells <span data-omnivore-anchor-idx="121" class="hljs-keyword">if</span> this thread <span data-omnivore-anchor-idx="122" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="123" class="hljs-built_in">running</span> <span data-omnivore-anchor-idx="124" class="hljs-keyword">on</span> a CPU <span data-omnivore-anchor-idx="125" class="hljs-keyword">or</span> <span data-omnivore-anchor-idx="126" class="hljs-keyword">not</span>. The only thing left <span data-omnivore-anchor-idx="127" class="hljs-keyword">for</span> user <span data-omnivore-anchor-idx="128" class="hljs-literal">space</span> <span data-omnivore-anchor-idx="129" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="130" class="hljs-keyword">to</span> check this field <span data-omnivore-anchor-idx="131" class="hljs-keyword">to</span> find out <span data-omnivore-anchor-idx="132" class="hljs-keyword">if</span> <span data-omnivore-anchor-idx="133" class="hljs-keyword">the</span> thread <span data-omnivore-anchor-idx="134" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="135" class="hljs-keyword">on</span> a CPU <span data-omnivore-anchor-idx="136" class="hljs-keyword">or</span> <span data-omnivore-anchor-idx="137" class="hljs-keyword">not</span>, <span data-omnivore-anchor-idx="138" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="139" class="hljs-keyword">then</span> <span data-omnivore-anchor-idx="140" class="hljs-keyword">it</span> can safely spin. Otherwise, <span data-omnivore-anchor-idx="141" class="hljs-keyword">it</span> goes <span data-omnivore-anchor-idx="142" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="143" class="hljs-keyword">the</span> normal path <span data-omnivore-anchor-idx="144" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="145" class="hljs-keyword">is</span> sleeping using futex.

So this <span data-omnivore-anchor-idx="146" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="147" class="hljs-keyword">the</span> proposed structure. Do you want <span data-omnivore-anchor-idx="148" class="hljs-keyword">to</span>...

Yeah, thank you. So, I’ll just remove <span data-omnivore-anchor-idx="149" class="hljs-keyword">that</span>. The proposed structure—this <span data-omnivore-anchor-idx="150" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="151" class="hljs-keyword">the</span> complex one. The simple one takes <span data-omnivore-anchor-idx="152" class="hljs-keyword">the</span> state <span data-omnivore-anchor-idx="153" class="hljs-keyword">in</span> <span data-omnivore-anchor-idx="154" class="hljs-keyword">the</span> thread ID <span data-omnivore-anchor-idx="155" class="hljs-keyword">and</span> moves <span data-omnivore-anchor-idx="156" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="157" class="hljs-keyword">back</span> right <span data-omnivore-anchor-idx="158" class="hljs-keyword">into</span> struct RAC. After <span data-omnivore-anchor-idx="159" class="hljs-keyword">some</span> discussion <span data-omnivore-anchor-idx="160" class="hljs-keyword">with</span> Carlos, I might go <span data-omnivore-anchor-idx="161" class="hljs-keyword">for</span> a simpler layout because there’s a trade-off. Either we make things complex like this <span data-omnivore-anchor-idx="162" class="hljs-keyword">to</span> have <span data-omnivore-anchor-idx="163" class="hljs-keyword">the</span> state information <span data-omnivore-anchor-idx="164" class="hljs-keyword">in</span> a separate cache line <span data-omnivore-anchor-idx="165" class="hljs-keyword">to</span> eliminate <span data-omnivore-anchor-idx="166" class="hljs-keyword">the</span> fact <span data-omnivore-anchor-idx="167" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="168" class="hljs-keyword">if</span> <span data-omnivore-anchor-idx="169" class="hljs-keyword">it</span>’s shared <span data-omnivore-anchor-idx="170" class="hljs-keyword">on</span> <span data-omnivore-anchor-idx="171" class="hljs-keyword">the</span> struct, <span data-omnivore-anchor-idx="172" class="hljs-keyword">if</span> we have high contention <span data-omnivore-anchor-idx="173" class="hljs-keyword">and</span> readers trying <span data-omnivore-anchor-idx="174" class="hljs-keyword">to</span> check <span data-omnivore-anchor-idx="175" class="hljs-keyword">that</span> state <span data-omnivore-anchor-idx="176" class="hljs-keyword">over</span> <span data-omnivore-anchor-idx="177" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="178" class="hljs-keyword">over</span> again, <span data-omnivore-anchor-idx="179" class="hljs-keyword">then</span> <span data-omnivore-anchor-idx="180" class="hljs-keyword">that</span> cache line becomes shared. If you have an RAC critical section <span data-omnivore-anchor-idx="181" class="hljs-keyword">beginning</span> <span data-omnivore-anchor-idx="182" class="hljs-keyword">and</span> want <span data-omnivore-anchor-idx="183" class="hljs-keyword">to</span> store there, <span data-omnivore-anchor-idx="184" class="hljs-keyword">that</span> store <span data-omnivore-anchor-idx="185" class="hljs-keyword">is</span> slightly more expensive—a few nanoseconds more, right?

So, there’s a slight overhead <span data-omnivore-anchor-idx="186" class="hljs-keyword">to</span> having this within <span data-omnivore-anchor-idx="187" class="hljs-keyword">the</span> same cache line, <span data-omnivore-anchor-idx="188" class="hljs-keyword">but</span> <span data-omnivore-anchor-idx="189" class="hljs-keyword">to</span> split <span data-omnivore-anchor-idx="190" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="191" class="hljs-keyword">into</span> a different cache line brings extra complexity <span data-omnivore-anchor-idx="192" class="hljs-keyword">for</span> all user <span data-omnivore-anchor-idx="193" class="hljs-literal">space</span> users, like LIPY, <span data-omnivore-anchor-idx="194" class="hljs-keyword">for</span> instance, <span data-omnivore-anchor-idx="195" class="hljs-keyword">where</span> they have <span data-omnivore-anchor-idx="196" class="hljs-keyword">to</span> make room <span data-omnivore-anchor-idx="197" class="hljs-keyword">and</span> allocate an area <span data-omnivore-anchor-idx="198" class="hljs-keyword">for</span> this separate `SK` state. So, yeah, <span data-omnivore-anchor-idx="199" class="hljs-keyword">it</span>’s a trade-off. There’s a slight performance advantage <span data-omnivore-anchor-idx="200" class="hljs-keyword">to</span> have an approach like this, <span data-omnivore-anchor-idx="201" class="hljs-keyword">where</span> <span data-omnivore-anchor-idx="202" class="hljs-keyword">in</span> struct SEC you have a pointer <span data-omnivore-anchor-idx="203" class="hljs-keyword">to</span> a separate cache line <span data-omnivore-anchor-idx="204" class="hljs-keyword">that</span> has <span data-omnivore-anchor-idx="205" class="hljs-keyword">the</span> state.

But, Michael, why don’t you blow up <span data-omnivore-anchor-idx="206" class="hljs-keyword">the</span> size <span data-omnivore-anchor-idx="207" class="hljs-keyword">of</span> struct RAC <span data-omnivore-anchor-idx="208" class="hljs-keyword">in</span> <span data-omnivore-anchor-idx="209" class="hljs-keyword">the</span> <span data-omnivore-anchor-idx="210" class="hljs-keyword">first</span> place?

No, no, <span data-omnivore-anchor-idx="211" class="hljs-keyword">not</span> why a pointer—just make <span data-omnivore-anchor-idx="212" class="hljs-keyword">it</span> <span data-omnivore-anchor-idx="213" class="hljs-keyword">that</span>. Yeah, <span data-omnivore-anchor-idx="214" class="hljs-keyword">that</span>’s two cache lines. 

So <span data-omnivore-anchor-idx="215" class="hljs-keyword">the</span> problem <span data-omnivore-anchor-idx="216" class="hljs-keyword">is</span>, <span data-omnivore-anchor-idx="217" class="hljs-keyword">if</span> I would have additional features <span data-omnivore-anchor-idx="218" class="hljs-keyword">to</span> add <span data-omnivore-anchor-idx="219" class="hljs-keyword">before</span> <span data-omnivore-anchor-idx="220" class="hljs-keyword">that</span>, I could pack them <span data-omnivore-anchor-idx="221" class="hljs-keyword">into</span> <span data-omnivore-anchor-idx="222" class="hljs-keyword">my</span> current cache line <span data-omnivore-anchor-idx="223" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="224" class="hljs-keyword">then</span> <span data-omnivore-anchor-idx="225" class="hljs-keyword">get</span> <span data-omnivore-anchor-idx="226" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="227" class="hljs-keyword">the</span> next one <span data-omnivore-anchor-idx="228" class="hljs-keyword">to</span> add this other feature. But <span data-omnivore-anchor-idx="229" class="hljs-keyword">if</span> I skip immediately <span data-omnivore-anchor-idx="230" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="231" class="hljs-keyword">the</span> next cache line, <span data-omnivore-anchor-idx="232" class="hljs-keyword">then</span> <span data-omnivore-anchor-idx="233" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="234" class="hljs-literal">space</span> becomes wasted <span data-omnivore-anchor-idx="235" class="hljs-literal">space</span>; <span data-omnivore-anchor-idx="236" class="hljs-keyword">it</span> becomes reserved <span data-omnivore-anchor-idx="237" class="hljs-literal">space</span>—<span data-omnivore-anchor-idx="238" class="hljs-keyword">it</span>’s unused <span data-omnivore-anchor-idx="239" class="hljs-keyword">at</span> <span data-omnivore-anchor-idx="240" class="hljs-keyword">that</span> point <span data-omnivore-anchor-idx="241" class="hljs-keyword">in</span> <span data-omnivore-anchor-idx="242" class="hljs-built_in">time</span>. But you can reuse <span data-omnivore-anchor-idx="243" class="hljs-keyword">it</span>.

Okay, <span data-omnivore-anchor-idx="244" class="hljs-keyword">but</span> <span data-omnivore-anchor-idx="245" class="hljs-keyword">then</span> I need a new way <span data-omnivore-anchor-idx="246" class="hljs-keyword">to</span> expose <span data-omnivore-anchor-idx="247" class="hljs-keyword">the</span> fact <span data-omnivore-anchor-idx="248" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="249" class="hljs-keyword">the</span> reserved state <span data-omnivore-anchor-idx="250" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="251" class="hljs-keyword">not</span> reserved anymore; <span data-omnivore-anchor-idx="252" class="hljs-keyword">it</span>’s now used. So I will use auxiliary vectors <span data-omnivore-anchor-idx="253" class="hljs-keyword">to</span> let <span data-omnivore-anchor-idx="254" class="hljs-keyword">the</span> kernel <span data-omnivore-anchor-idx="255" class="hljs-keyword">tell</span> user <span data-omnivore-anchor-idx="256" class="hljs-literal">space</span> how much <span data-omnivore-anchor-idx="257" class="hljs-keyword">of</span> <span data-omnivore-anchor-idx="258" class="hljs-keyword">the</span> area <span data-omnivore-anchor-idx="259" class="hljs-keyword">is</span> actually populated. If I skip <span data-omnivore-anchor-idx="260" class="hljs-keyword">with</span> padding, <span data-omnivore-anchor-idx="261" class="hljs-keyword">then</span> I need <span data-omnivore-anchor-idx="262" class="hljs-keyword">some</span> mechanism <span data-omnivore-anchor-idx="263" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="264" class="hljs-built_in">say</span>, “Well, this padding <span data-omnivore-anchor-idx="265" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="266" class="hljs-keyword">not</span> padding anymore.” So either I leave <span data-omnivore-anchor-idx="267" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="268" class="hljs-keyword">as</span> padding <span data-omnivore-anchor-idx="269" class="hljs-keyword">or</span> I need a new mechanism.

Yeah, thanks. So, do you want <span data-omnivore-anchor-idx="270" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="271" class="hljs-keyword">continue</span>?

Yeah, so another concern <span data-omnivore-anchor-idx="272" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="273" class="hljs-keyword">about</span> robustness because this interface requires reading shared thread information. The idea here <span data-omnivore-anchor-idx="274" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="275" class="hljs-keyword">that</span> user <span data-omnivore-anchor-idx="276" class="hljs-literal">space</span> implements something <span data-omnivore-anchor-idx="277" class="hljs-keyword">that</span>, <span data-omnivore-anchor-idx="278" class="hljs-keyword">before</span> <span data-omnivore-anchor-idx="279" class="hljs-keyword">the</span> thread dies, <span data-omnivore-anchor-idx="280" class="hljs-keyword">it</span> will free <span data-omnivore-anchor-idx="281" class="hljs-keyword">the</span> lock <span data-omnivore-anchor-idx="282" class="hljs-keyword">in</span> <span data-omnivore-anchor-idx="283" class="hljs-keyword">the</span> <span data-omnivore-anchor-idx="284" class="hljs-keyword">exit</span> path. We can use <span data-omnivore-anchor-idx="285" class="hljs-keyword">the</span> RAC memory barriers <span data-omnivore-anchor-idx="286" class="hljs-keyword">to</span> protect this field <span data-omnivore-anchor-idx="287" class="hljs-keyword">before</span>, so we make sure <span data-omnivore-anchor-idx="288" class="hljs-keyword">that</span> when you are reading <span data-omnivore-anchor-idx="289" class="hljs-keyword">the</span> `sched_state`, you are reading something <span data-omnivore-anchor-idx="290" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="291" class="hljs-keyword">is</span> meaningful. 

But we can have this <span data-omnivore-anchor-idx="292" class="hljs-keyword">for</span> different processes; we can only use these <span data-omnivore-anchor-idx="293" class="hljs-keyword">for</span> threads. So <span data-omnivore-anchor-idx="294" class="hljs-keyword">the</span> question <span data-omnivore-anchor-idx="295" class="hljs-keyword">is</span>, <span data-omnivore-anchor-idx="296" class="hljs-keyword">is</span> this a concern?

Yeah, <span data-omnivore-anchor-idx="297" class="hljs-keyword">if</span> I can just rephrase—one <span data-omnivore-anchor-idx="298" class="hljs-keyword">of</span> <span data-omnivore-anchor-idx="299" class="hljs-keyword">the</span> things <span data-omnivore-anchor-idx="300" class="hljs-keyword">that</span> we would need <span data-omnivore-anchor-idx="301" class="hljs-keyword">for</span> <span data-omnivore-anchor-idx="302" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="303" class="hljs-keyword">is</span> integration <span data-omnivore-anchor-idx="304" class="hljs-keyword">with</span> LIPY. LIPY, when <span data-omnivore-anchor-idx="305" class="hljs-keyword">it</span> reclaims <span data-omnivore-anchor-idx="306" class="hljs-keyword">some</span> thread memory, <span data-omnivore-anchor-idx="307" class="hljs-keyword">it</span> issues an RC fence <span data-omnivore-anchor-idx="308" class="hljs-keyword">through</span> M barrier so <span data-omnivore-anchor-idx="309" class="hljs-keyword">that</span> whatever threads are trying <span data-omnivore-anchor-idx="310" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="311" class="hljs-built_in">read</span> <span data-omnivore-anchor-idx="312" class="hljs-keyword">that</span> CPU state <span data-omnivore-anchor-idx="313" class="hljs-keyword">from</span> <span data-omnivore-anchor-idx="314" class="hljs-keyword">that</span> specific thread's memory can use our SEC critical section <span data-omnivore-anchor-idx="315" class="hljs-keyword">to</span> do <span data-omnivore-anchor-idx="316" class="hljs-keyword">that</span> load, so <span data-omnivore-anchor-idx="317" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="318" class="hljs-keyword">it</span> gets aborted <span data-omnivore-anchor-idx="319" class="hljs-keyword">if</span> <span data-omnivore-anchor-idx="320" class="hljs-keyword">the</span> memory <span data-omnivore-anchor-idx="321" class="hljs-keyword">it</span> wants <span data-omnivore-anchor-idx="322" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="323" class="hljs-built_in">read</span> <span data-omnivore-anchor-idx="324" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="325" class="hljs-keyword">about</span> <span data-omnivore-anchor-idx="326" class="hljs-keyword">to</span> be reclaimed. That’s <span data-omnivore-anchor-idx="327" class="hljs-keyword">the</span> idea <span data-omnivore-anchor-idx="328" class="hljs-keyword">of</span> how <span data-omnivore-anchor-idx="329" class="hljs-keyword">to</span> kind <span data-omnivore-anchor-idx="330" class="hljs-keyword">of</span> make things work <span data-omnivore-anchor-idx="331" class="hljs-keyword">in</span> terms <span data-omnivore-anchor-idx="332" class="hljs-keyword">of</span> this.

And <span data-omnivore-anchor-idx="333" class="hljs-keyword">of</span> course, because we need <span data-omnivore-anchor-idx="334" class="hljs-keyword">to</span> have access <span data-omnivore-anchor-idx="335" class="hljs-keyword">to</span> other thread's memory, <span data-omnivore-anchor-idx="336" class="hljs-keyword">it</span> only works <span data-omnivore-anchor-idx="337" class="hljs-keyword">for</span> private futexes; <span data-omnivore-anchor-idx="338" class="hljs-keyword">it</span> <span data-omnivore-anchor-idx="339" class="hljs-keyword">does</span> <span data-omnivore-anchor-idx="340" class="hljs-keyword">not</span> work <span data-omnivore-anchor-idx="341" class="hljs-keyword">for</span> <span data-omnivore-anchor-idx="342" class="hljs-keyword">the</span> shared case <span data-omnivore-anchor-idx="343" class="hljs-keyword">where</span> we have shared memory mutexes <span data-omnivore-anchor-idx="344" class="hljs-keyword">and</span> shared memory across processes. That’s a current limitation, <span data-omnivore-anchor-idx="345" class="hljs-keyword">but</span> I mean, there seems <span data-omnivore-anchor-idx="346" class="hljs-keyword">to</span> be quite a lot <span data-omnivore-anchor-idx="347" class="hljs-keyword">of</span> use cases <span data-omnivore-anchor-idx="348" class="hljs-keyword">that</span> would still benefit <span data-omnivore-anchor-idx="349" class="hljs-keyword">from</span> <span data-omnivore-anchor-idx="350" class="hljs-keyword">that</span>. 

There’s a question—Thomas?

Thomas: So, did you talk <span data-omnivore-anchor-idx="351" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="352" class="hljs-keyword">the</span> obvious suspects, like database people <span data-omnivore-anchor-idx="353" class="hljs-keyword">or</span> Keen, <span data-omnivore-anchor-idx="354" class="hljs-keyword">about</span> user <span data-omnivore-anchor-idx="355" class="hljs-literal">space</span> spin locks? Are they happy <span data-omnivore-anchor-idx="356" class="hljs-keyword">with</span> having <span data-omnivore-anchor-idx="357" class="hljs-keyword">it</span> limited <span data-omnivore-anchor-idx="358" class="hljs-keyword">to</span> threads? Because I know <span data-omnivore-anchor-idx="359" class="hljs-keyword">at</span> least one major database which <span data-omnivore-anchor-idx="360" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="361" class="hljs-keyword">not</span>—<span data-omnivore-anchor-idx="362" class="hljs-keyword">it</span>’s process-based.

You should talk <span data-omnivore-anchor-idx="363" class="hljs-keyword">to</span> them because they might be rather unhappy. There might be other ways <span data-omnivore-anchor-idx="364" class="hljs-keyword">to</span> work <span data-omnivore-anchor-idx="365" class="hljs-keyword">around</span> <span data-omnivore-anchor-idx="366" class="hljs-keyword">that</span>, <span data-omnivore-anchor-idx="367" class="hljs-keyword">but</span> we’d have <span data-omnivore-anchor-idx="368" class="hljs-keyword">some</span> way <span data-omnivore-anchor-idx="369" class="hljs-keyword">to</span> kind <span data-omnivore-anchor-idx="370" class="hljs-keyword">of</span> let threads speak <span data-omnivore-anchor-idx="371" class="hljs-keyword">to</span> other threads. I mean, we want <span data-omnivore-anchor-idx="372" class="hljs-keyword">to</span> quickly have <span data-omnivore-anchor-idx="373" class="hljs-keyword">the</span> answer <span data-omnivore-anchor-idx="374" class="hljs-keyword">of</span> whether <span data-omnivore-anchor-idx="375" class="hljs-keyword">the</span> owner thread <span data-omnivore-anchor-idx="376" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="377" class="hljs-keyword">on</span> CPU <span data-omnivore-anchor-idx="378" class="hljs-keyword">or</span> <span data-omnivore-anchor-idx="379" class="hljs-keyword">not</span>, so <span data-omnivore-anchor-idx="380" class="hljs-keyword">it</span> needs <span data-omnivore-anchor-idx="381" class="hljs-keyword">to</span> sit <span data-omnivore-anchor-idx="382" class="hljs-keyword">in</span> memory somewhere, <span data-omnivore-anchor-idx="383" class="hljs-keyword">in</span> a memory area <span data-omnivore-anchor-idx="384" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="385" class="hljs-keyword">is</span> readable directly <span data-omnivore-anchor-idx="386" class="hljs-keyword">by</span> <span data-omnivore-anchor-idx="387" class="hljs-keyword">the</span> potential threads.

Maybe <span data-omnivore-anchor-idx="388" class="hljs-keyword">that</span> could be two separate implementations, right? One <span data-omnivore-anchor-idx="389" class="hljs-keyword">for</span> <span data-omnivore-anchor-idx="390" class="hljs-keyword">the</span> private <span data-omnivore-anchor-idx="391" class="hljs-keyword">and</span> one <span data-omnivore-anchor-idx="392" class="hljs-keyword">for</span> <span data-omnivore-anchor-idx="393" class="hljs-keyword">the</span> non-private. For <span data-omnivore-anchor-idx="394" class="hljs-keyword">the</span> other processes, you probably need a pointer <span data-omnivore-anchor-idx="395" class="hljs-keyword">or</span> something <span data-omnivore-anchor-idx="396" class="hljs-keyword">to</span> another shared memory <span data-omnivore-anchor-idx="397" class="hljs-keyword">that</span> would be able. Maybe <span data-omnivore-anchor-idx="398" class="hljs-keyword">it</span> could be even mapped always <span data-omnivore-anchor-idx="399" class="hljs-keyword">from</span> <span data-omnivore-anchor-idx="400" class="hljs-keyword">the</span> kernel <span data-omnivore-anchor-idx="401" class="hljs-keyword">to</span> user <span data-omnivore-anchor-idx="402" class="hljs-literal">space</span>. It would have <span data-omnivore-anchor-idx="403" class="hljs-keyword">to</span> be <span data-omnivore-anchor-idx="404" class="hljs-keyword">set</span> up so you’d have <span data-omnivore-anchor-idx="405" class="hljs-keyword">it</span> mapped so <span data-omnivore-anchor-idx="406" class="hljs-keyword">it</span> doesn’t <span data-omnivore-anchor-idx="407" class="hljs-keyword">get</span>... 

It’s <span data-omnivore-anchor-idx="408" class="hljs-keyword">not</span> like RC, which I understand <span data-omnivore-anchor-idx="409" class="hljs-keyword">is</span> just memory <span data-omnivore-anchor-idx="410" class="hljs-keyword">in</span> user <span data-omnivore-anchor-idx="411" class="hljs-literal">space</span>, <span data-omnivore-anchor-idx="412" class="hljs-keyword">and</span> when <span data-omnivore-anchor-idx="413" class="hljs-keyword">the</span> kernel wants <span data-omnivore-anchor-idx="414" class="hljs-keyword">to</span>... It’s got <span data-omnivore-anchor-idx="415" class="hljs-keyword">to</span> do a user... 

Yes, which also raises a question—when <span data-omnivore-anchor-idx="416" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="417" class="hljs-keyword">the</span> thing <span data-omnivore-anchor-idx="418" class="hljs-keyword">set</span> <span data-omnivore-anchor-idx="419" class="hljs-keyword">that</span> says I’m off <span data-omnivore-anchor-idx="420" class="hljs-keyword">the</span> CPU? Is <span data-omnivore-anchor-idx="421" class="hljs-keyword">it</span> right <span data-omnivore-anchor-idx="422" class="hljs-keyword">in</span> <span data-omnivore-anchor-idx="423" class="hljs-keyword">the</span> scheduler?

Yes, <span data-omnivore-anchor-idx="424" class="hljs-keyword">it</span> <span data-omnivore-anchor-idx="425" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="426" class="hljs-keyword">set</span> currently when <span data-omnivore-anchor-idx="427" class="hljs-keyword">the</span> scheduler <span data-omnivore-anchor-idx="428" class="hljs-keyword">is</span> preempting <span data-omnivore-anchor-idx="429" class="hljs-keyword">the</span> task. But <span data-omnivore-anchor-idx="430" class="hljs-keyword">it</span>’s a statistical hint, right? That store cannot take a page fault, right? So <span data-omnivore-anchor-idx="431" class="hljs-keyword">if</span> <span data-omnivore-anchor-idx="432" class="hljs-keyword">that</span> page would happen <span data-omnivore-anchor-idx="433" class="hljs-keyword">to</span> be faulted, <span data-omnivore-anchor-idx="434" class="hljs-keyword">then</span> <span data-omnivore-anchor-idx="435" class="hljs-keyword">it</span>’s <span data-omnivore-anchor-idx="436" class="hljs-keyword">not</span> doing anything—<span data-omnivore-anchor-idx="437" class="hljs-keyword">the</span> state <span data-omnivore-anchor-idx="438" class="hljs-keyword">is</span> wrong <span data-omnivore-anchor-idx="439" class="hljs-keyword">until</span> <span data-omnivore-anchor-idx="440" class="hljs-keyword">it</span>’s going <span data-omnivore-anchor-idx="441" class="hljs-keyword">back</span> <span data-omnivore-anchor-idx="442" class="hljs-keyword">to</span> user <span data-omnivore-anchor-idx="443" class="hljs-literal">space</span>, <span data-omnivore-anchor-idx="444" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="445" class="hljs-keyword">then</span> we can take <span data-omnivore-anchor-idx="446" class="hljs-keyword">the</span> page fault.

Okay, <span data-omnivore-anchor-idx="447" class="hljs-keyword">but</span> <span data-omnivore-anchor-idx="448" class="hljs-keyword">if</span> <span data-omnivore-anchor-idx="449" class="hljs-keyword">it</span>’s going <span data-omnivore-anchor-idx="450" class="hljs-keyword">back</span> <span data-omnivore-anchor-idx="451" class="hljs-keyword">to</span> user <span data-omnivore-anchor-idx="452" class="hljs-literal">space</span>, <span data-omnivore-anchor-idx="453" class="hljs-keyword">then</span> you schedule <span data-omnivore-anchor-idx="454" class="hljs-keyword">it</span> again?

Yes, <span data-omnivore-anchor-idx="455" class="hljs-keyword">that</span>’s right. But <span data-omnivore-anchor-idx="456" class="hljs-keyword">then</span> <span data-omnivore-anchor-idx="457" class="hljs-keyword">it</span>’s faulted <span data-omnivore-anchor-idx="458" class="hljs-keyword">in</span>, <span data-omnivore-anchor-idx="459" class="hljs-keyword">and</span> you need <span data-omnivore-anchor-idx="460" class="hljs-keyword">to</span> be really unlucky <span data-omnivore-anchor-idx="461" class="hljs-keyword">to</span> have <span data-omnivore-anchor-idx="462" class="hljs-keyword">it</span> faulted out again, right? Paged out, sorry.

One workaround <span data-omnivore-anchor-idx="463" class="hljs-keyword">for</span> this <span data-omnivore-anchor-idx="464" class="hljs-keyword">that</span> I talked <span data-omnivore-anchor-idx="465" class="hljs-keyword">about</span> <span data-omnivore-anchor-idx="466" class="hljs-keyword">but</span> did <span data-omnivore-anchor-idx="467" class="hljs-keyword">not</span> implement <span data-omnivore-anchor-idx="468" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="469" class="hljs-keyword">if</span> <span data-omnivore-anchor-idx="470" class="hljs-keyword">that</span> state <span data-omnivore-anchor-idx="471" class="hljs-keyword">is</span> really important <span data-omnivore-anchor-idx="472" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="473" class="hljs-keyword">get</span> right <span data-omnivore-anchor-idx="474" class="hljs-number">100</span>%, I think we could hook <span data-omnivore-anchor-idx="475" class="hljs-keyword">into</span> <span data-omnivore-anchor-idx="476" class="hljs-keyword">the</span> page fault handler <span data-omnivore-anchor-idx="477" class="hljs-keyword">for</span> <span data-omnivore-anchor-idx="478" class="hljs-keyword">the</span> reads. The scheduler cannot update <span data-omnivore-anchor-idx="479" class="hljs-keyword">the</span> state, <span data-omnivore-anchor-idx="480" class="hljs-keyword">but</span> <span data-omnivore-anchor-idx="481" class="hljs-keyword">it</span> can tag <span data-omnivore-anchor-idx="482" class="hljs-keyword">the</span> process <span data-omnivore-anchor-idx="483" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="484" class="hljs-built_in">say</span>, “Well, <span data-omnivore-anchor-idx="485" class="hljs-keyword">the</span> state <span data-omnivore-anchor-idx="486" class="hljs-keyword">for</span> <span data-omnivore-anchor-idx="487" class="hljs-keyword">that</span> page <span data-omnivore-anchor-idx="488" class="hljs-keyword">is</span> actually currently wrong.” 

So <span data-omnivore-anchor-idx="489" class="hljs-keyword">on</span> <span data-omnivore-anchor-idx="490" class="hljs-keyword">the</span> next page fault <span data-omnivore-anchor-idx="491" class="hljs-keyword">for</span> reads, when <span data-omnivore-anchor-idx="492" class="hljs-keyword">it</span> tries <span data-omnivore-anchor-idx="493" class="hljs-keyword">to</span> access <span data-omnivore-anchor-idx="494" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="495" class="hljs-built_in">read</span> <span data-omnivore-anchor-idx="496" class="hljs-keyword">the</span> state, <span data-omnivore-anchor-idx="497" class="hljs-keyword">the</span> right information will be populated <span data-omnivore-anchor-idx="498" class="hljs-keyword">before</span> <span data-omnivore-anchor-idx="499" class="hljs-keyword">the</span> process <span data-omnivore-anchor-idx="500" class="hljs-keyword">is</span> allowed <span data-omnivore-anchor-idx="501" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="502" class="hljs-built_in">read</span> <span data-omnivore-anchor-idx="503" class="hljs-keyword">the</span> page. 

So basically, when <span data-omnivore-anchor-idx="504" class="hljs-keyword">the</span> other CPU says, “Read this page,” <span data-omnivore-anchor-idx="505" class="hljs-keyword">it</span>’s going <span data-omnivore-anchor-idx="506" class="hljs-keyword">to</span> actually take <span data-omnivore-anchor-idx="507" class="hljs-keyword">the</span> fault, <span data-omnivore-anchor-idx="508" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="509" class="hljs-keyword">it</span>’s going <span data-omnivore-anchor-idx="510" class="hljs-keyword">to</span> actually update <span data-omnivore-anchor-idx="511" class="hljs-keyword">the</span> status. 

So we could actually... Yeah, just have <span data-omnivore-anchor-idx="512" class="hljs-keyword">the</span> status <span data-omnivore-anchor-idx="513" class="hljs-keyword">in</span> <span data-omnivore-anchor-idx="514" class="hljs-keyword">the</span> task struct, <span data-omnivore-anchor-idx="515" class="hljs-keyword">or</span> something like <span data-omnivore-anchor-idx="516" class="hljs-keyword">that</span>, <span data-omnivore-anchor-idx="517" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="518" class="hljs-built_in">say</span>, “Are you <span data-omnivore-anchor-idx="519" class="hljs-keyword">on</span> <span data-omnivore-anchor-idx="520" class="hljs-keyword">the</span> <span data-omnivore-anchor-idx="521" class="hljs-built_in">run</span> queue?” And <span data-omnivore-anchor-idx="522" class="hljs-keyword">then</span> when <span data-omnivore-anchor-idx="523" class="hljs-keyword">it</span> faults <span data-omnivore-anchor-idx="524" class="hljs-keyword">in</span>, <span data-omnivore-anchor-idx="525" class="hljs-built_in">say</span>, “Okay, do <span data-omnivore-anchor-idx="526" class="hljs-keyword">it</span> this way.” 

That could, I guess, work out.

Good!

All right, yeah, we just covered this—<span data-omnivore-anchor-idx="527" class="hljs-keyword">the</span> correctness slide—<span data-omnivore-anchor-idx="528" class="hljs-keyword">by</span> accident. Overall, I’m curious what <span data-omnivore-anchor-idx="529" class="hljs-keyword">the</span> performance benefits are versus avoiding <span data-omnivore-anchor-idx="530" class="hljs-keyword">the</span> context switches. 

When you’re spinning <span data-omnivore-anchor-idx="531" class="hljs-keyword">in</span> <span data-omnivore-anchor-idx="532" class="hljs-keyword">the</span> kernel, spinning <span data-omnivore-anchor-idx="533" class="hljs-keyword">on</span> <span data-omnivore-anchor-idx="534" class="hljs-keyword">the</span> owner, you have really specific MCS locks, so there’s a trade-off there. Have you determined which one <span data-omnivore-anchor-idx="535" class="hljs-keyword">is</span> better? In <span data-omnivore-anchor-idx="536" class="hljs-keyword">some</span> cases, <span data-omnivore-anchor-idx="537" class="hljs-keyword">does</span> <span data-omnivore-anchor-idx="538" class="hljs-keyword">it</span> matter even <span data-omnivore-anchor-idx="539" class="hljs-keyword">with</span> <span data-omnivore-anchor-idx="540" class="hljs-keyword">the</span> context switch, still using better cache lines?

I have <span data-omnivore-anchor-idx="541" class="hljs-keyword">not</span> worked <span data-omnivore-anchor-idx="542" class="hljs-keyword">on</span> any benchmarks <span data-omnivore-anchor-idx="543" class="hljs-keyword">on</span> this. I mean, I’ve seen <span data-omnivore-anchor-idx="544" class="hljs-keyword">the</span> LWN article <span data-omnivore-anchor-idx="545" class="hljs-keyword">about</span> what you were trying <span data-omnivore-anchor-idx="546" class="hljs-keyword">to</span> achieve, <span data-omnivore-anchor-idx="547" class="hljs-keyword">and</span> I was like, “I can do <span data-omnivore-anchor-idx="548" class="hljs-keyword">that</span>!” So I did <span data-omnivore-anchor-idx="549" class="hljs-keyword">that</span>. The benchmark part <span data-omnivore-anchor-idx="550" class="hljs-keyword">and</span> trying <span data-omnivore-anchor-idx="551" class="hljs-keyword">to</span> figure out <span data-omnivore-anchor-idx="552" class="hljs-keyword">where</span> <span data-omnivore-anchor-idx="553" class="hljs-keyword">it</span> makes sense—I leave <span data-omnivore-anchor-idx="554" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="555" class="hljs-keyword">to</span> Andrea.

Yeah, <span data-omnivore-anchor-idx="556" class="hljs-keyword">but</span> I didn't... Mark already—you were trying <span data-omnivore-anchor-idx="557" class="hljs-keyword">to</span> figure out <span data-omnivore-anchor-idx="558" class="hljs-keyword">the</span> proper design. 

Yeah, because once you incur <span data-omnivore-anchor-idx="559" class="hljs-keyword">in</span> <span data-omnivore-anchor-idx="560" class="hljs-keyword">the</span> context switch, you know <span data-omnivore-anchor-idx="561" class="hljs-keyword">the</span> MCS properties. OSQ lock specifically really boosts performance—<span data-omnivore-anchor-idx="562" class="hljs-keyword">that</span>'s all.

I mean, <span data-omnivore-anchor-idx="563" class="hljs-keyword">that</span> would really be important information <span data-omnivore-anchor-idx="564" class="hljs-keyword">to</span> have because <span data-omnivore-anchor-idx="565" class="hljs-keyword">if</span> you look <span data-omnivore-anchor-idx="566" class="hljs-keyword">at</span> <span data-omnivore-anchor-idx="567" class="hljs-keyword">the</span> right now, <span data-omnivore-anchor-idx="568" class="hljs-keyword">the</span> syscall overhead <span data-omnivore-anchor-idx="569" class="hljs-keyword">is</span> mostly <span data-omnivore-anchor-idx="570" class="hljs-keyword">that</span> <span data-omnivore-anchor-idx="571" class="hljs-keyword">it</span>’s scheduled out. It’s <span data-omnivore-anchor-idx="572" class="hljs-keyword">not</span> <span data-omnivore-anchor-idx="573" class="hljs-keyword">that</span> you’re going <span data-omnivore-anchor-idx="574" class="hljs-keyword">into</span> <span data-omnivore-anchor-idx="575" class="hljs-keyword">the</span> kernel. I mean, syscalls <span data-omnivore-anchor-idx="576" class="hljs-number">20</span> years ago have been expensive <span data-omnivore-anchor-idx="577" class="hljs-keyword">from</span> <span data-omnivore-anchor-idx="578" class="hljs-keyword">the</span> hardware point <span data-omnivore-anchor-idx="579" class="hljs-keyword">of</span> view, <span data-omnivore-anchor-idx="580" class="hljs-keyword">but</span> <span data-omnivore-anchor-idx="581" class="hljs-keyword">it</span>’s <span data-omnivore-anchor-idx="582" class="hljs-keyword">not</span> longer <span data-omnivore-anchor-idx="583" class="hljs-keyword">that</span> horrible.

No, <span data-omnivore-anchor-idx="584" class="hljs-keyword">with</span> mitigations <span data-omnivore-anchor-idx="585" class="hljs-keyword">on</span>, they are... 

Yeah, <span data-omnivore-anchor-idx="586" class="hljs-keyword">but</span> come <span data-omnivore-anchor-idx="587" class="hljs-keyword">on</span>, we’re <span data-omnivore-anchor-idx="588" class="hljs-keyword">not</span> optimizing <span data-omnivore-anchor-idx="589" class="hljs-keyword">for</span> PTI-affected machines.

No, we don’t. It’s stupid, really. But give us information <span data-omnivore-anchor-idx="590" class="hljs-keyword">about</span> what <span data-omnivore-anchor-idx="591" class="hljs-keyword">it</span> takes <span data-omnivore-anchor-idx="592" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="593" class="hljs-keyword">get</span> <span data-omnivore-anchor-idx="594" class="hljs-keyword">into</span>... what’s <span data-omnivore-anchor-idx="595" class="hljs-keyword">the</span> <span data-omnivore-anchor-idx="596" class="hljs-built_in">real</span> advantage, <span data-omnivore-anchor-idx="597" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="598" class="hljs-keyword">does</span> <span data-omnivore-anchor-idx="599" class="hljs-keyword">it</span> matter? That’s <span data-omnivore-anchor-idx="600" class="hljs-keyword">the</span> main question. 

I mean, obviously, everybody out there who <span data-omnivore-anchor-idx="601" class="hljs-keyword">does</span> user <span data-omnivore-anchor-idx="602" class="hljs-literal">space</span> spin locks will <span data-omnivore-anchor-idx="603" class="hljs-keyword">tell</span> you, “Of course <span data-omnivore-anchor-idx="604" class="hljs-keyword">it</span> matters because <span data-omnivore-anchor-idx="605" class="hljs-keyword">it</span> gains us so much performance.” And <span data-omnivore-anchor-idx="606" class="hljs-keyword">then</span>, <span data-omnivore-anchor-idx="607" class="hljs-keyword">if</span> you do <span data-omnivore-anchor-idx="608" class="hljs-built_in">real</span>-world benchmarks, <span data-omnivore-anchor-idx="609" class="hljs-keyword">it</span> turns out <span data-omnivore-anchor-idx="610" class="hljs-keyword">to</span> be completely irrelevant. 

So this <span data-omnivore-anchor-idx="611" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="612" class="hljs-keyword">the</span> <span data-omnivore-anchor-idx="613" class="hljs-built_in">real</span> question we want <span data-omnivore-anchor-idx="614" class="hljs-keyword">to</span> have because <span data-omnivore-anchor-idx="615" class="hljs-keyword">the</span> spinning mechanism itself—we have <span data-omnivore-anchor-idx="616" class="hljs-keyword">in</span> <span data-omnivore-anchor-idx="617" class="hljs-keyword">the</span> kernel—let people have information <span data-omnivore-anchor-idx="618" class="hljs-keyword">about</span> <span data-omnivore-anchor-idx="619" class="hljs-keyword">that</span> because their own mutex implementation has <span data-omnivore-anchor-idx="620" class="hljs-keyword">some</span> heuristics <span data-omnivore-anchor-idx="621" class="hljs-keyword">about</span> how much <span data-omnivore-anchor-idx="622" class="hljs-keyword">it</span> needs <span data-omnivore-anchor-idx="623" class="hljs-keyword">to</span> spin <span data-omnivore-anchor-idx="624" class="hljs-keyword">before</span> going <span data-omnivore-anchor-idx="625" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="626" class="hljs-keyword">the</span> kernel. 

So there are already <span data-omnivore-anchor-idx="627" class="hljs-keyword">some</span> mitigations <span data-omnivore-anchor-idx="628" class="hljs-keyword">in</span> place <span data-omnivore-anchor-idx="629" class="hljs-keyword">to</span> kind <span data-omnivore-anchor-idx="630" class="hljs-keyword">of</span>...

Yeah, <span data-omnivore-anchor-idx="631" class="hljs-keyword">but</span> they’re all wrong.

Yes, well, <span data-omnivore-anchor-idx="632" class="hljs-keyword">that</span>’s why we want <span data-omnivore-anchor-idx="633" class="hljs-keyword">to</span> provide <span data-omnivore-anchor-idx="634" class="hljs-keyword">the</span> right information <span data-omnivore-anchor-idx="635" class="hljs-keyword">from</span> <span data-omnivore-anchor-idx="636" class="hljs-keyword">the</span> scheduler <span data-omnivore-anchor-idx="637" class="hljs-keyword">to</span> let them easily do <span data-omnivore-anchor-idx="638" class="hljs-keyword">the</span> right thing. 

But Matthew, <span data-omnivore-anchor-idx="639" class="hljs-keyword">the</span> main problem <span data-omnivore-anchor-idx="640" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="641" class="hljs-keyword">that</span> today’s implementation—<span data-omnivore-anchor-idx="642" class="hljs-keyword">and</span> I was yelling <span data-omnivore-anchor-idx="643" class="hljs-keyword">at</span> people <span data-omnivore-anchor-idx="644" class="hljs-number">10</span> years ago <span data-omnivore-anchor-idx="645" class="hljs-keyword">and</span> told them <span data-omnivore-anchor-idx="646" class="hljs-keyword">to</span> implement spinning <span data-omnivore-anchor-idx="647" class="hljs-keyword">in</span> <span data-omnivore-anchor-idx="648" class="hljs-keyword">the</span> futex code <span data-omnivore-anchor-idx="649" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="650" class="hljs-keyword">then</span> compare <span data-omnivore-anchor-idx="651" class="hljs-keyword">and</span> contrast because <span data-omnivore-anchor-idx="652" class="hljs-keyword">then</span> you can just go <span data-omnivore-anchor-idx="653" class="hljs-keyword">into</span> <span data-omnivore-anchor-idx="654" class="hljs-keyword">the</span> kernel <span data-omnivore-anchor-idx="655" class="hljs-keyword">without</span> having htics. 

And we all know <span data-omnivore-anchor-idx="656" class="hljs-keyword">that</span> htics suck. So <span data-omnivore-anchor-idx="657" class="hljs-keyword">the</span> kernel has all <span data-omnivore-anchor-idx="658" class="hljs-keyword">the</span> information ready <span data-omnivore-anchor-idx="659" class="hljs-keyword">and</span> can do <span data-omnivore-anchor-idx="660" class="hljs-keyword">the</span> right thing <span data-omnivore-anchor-idx="661" class="hljs-keyword">without</span> having <span data-omnivore-anchor-idx="662" class="hljs-keyword">to</span> have a page fault handler <span data-omnivore-anchor-idx="663" class="hljs-keyword">and</span> a whatever handler <span data-omnivore-anchor-idx="664" class="hljs-keyword">and</span> magically-mapped memory. No, all <span data-omnivore-anchor-idx="665" class="hljs-keyword">that</span>’s <span data-omnivore-anchor-idx="666" class="hljs-keyword">not</span> necessary. 

So <span data-omnivore-anchor-idx="667" class="hljs-keyword">the</span> <span data-omnivore-anchor-idx="668" class="hljs-keyword">first</span> tradeoff—<span data-omnivore-anchor-idx="669" class="hljs-keyword">the</span> <span data-omnivore-anchor-idx="670" class="hljs-keyword">first</span> metric we need <span data-omnivore-anchor-idx="671" class="hljs-keyword">is</span> <span data-omnivore-anchor-idx="672" class="hljs-keyword">the</span> cost <span data-omnivore-anchor-idx="673" class="hljs-keyword">of</span> doing <span data-omnivore-anchor-idx="674" class="hljs-keyword">the</span> <span data-omnivore-anchor-idx="675" class="hljs-built_in">round</span> trip <span data-omnivore-anchor-idx="676" class="hljs-keyword">back</span> <span data-omnivore-anchor-idx="677" class="hljs-keyword">and</span> forth <span data-omnivore-anchor-idx="678" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="679" class="hljs-keyword">the</span> kernel compared <span data-omnivore-anchor-idx="680" class="hljs-keyword">to</span> <span data-omnivore-anchor-idx="681" class="hljs-keyword">the</span> little patches I sent out <span data-omnivore-anchor-idx="682" class="hljs-keyword">with</span> <span data-omnivore-anchor-idx="683" class="hljs-keyword">the</span> extended <span data-omnivore-anchor-idx="684" class="hljs-built_in">time</span> scheduler thing <span data-omnivore-anchor-idx="685" class="hljs-keyword">that</span> I kind <span data-omnivore-anchor-idx="686" class="hljs-keyword">of</span> played <span data-omnivore-anchor-idx="687" class="hljs-keyword">with</span>. 

I just did a test measuring a benchmark <span data-omnivore-anchor-idx="688" class="hljs-keyword">on</span> just measuring <span data-omnivore-anchor-idx="689" class="hljs-keyword">its</span> own little spin locks, <span data-omnivore-anchor-idx="690" class="hljs-keyword">where</span> I would grab a lock, do something, <span data-omnivore-anchor-idx="691" class="hljs-keyword">and</span> release. I grabbed a lock, <span data-omnivore-anchor-idx="692" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="693" class="hljs-keyword">then</span> I had <span data-omnivore-anchor-idx="694" class="hljs-keyword">some</span> contention <span data-omnivore-anchor-idx="695" class="hljs-keyword">on</span> <span data-omnivore-anchor-idx="696" class="hljs-keyword">it</span>, <span data-omnivore-anchor-idx="697" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="698" class="hljs-keyword">then</span> I switched <span data-omnivore-anchor-idx="699" class="hljs-keyword">it</span> <span data-omnivore-anchor-idx="700" class="hljs-keyword">to</span> a few texts <span data-omnivore-anchor-idx="701" class="hljs-keyword">and</span> said, “Okay, just let <span data-omnivore-anchor-idx="702" class="hljs-keyword">it</span>.” If <span data-omnivore-anchor-idx="703" class="hljs-keyword">it</span> goes <span data-omnivore-anchor-idx="704" class="hljs-keyword">in</span> <span data-omnivore-anchor-idx="705" class="hljs-keyword">with</span> <span data-omnivore-anchor-idx="706" class="hljs-keyword">the</span> spinning <span data-omnivore-anchor-idx="707" class="hljs-keyword">and</span> everything, <span data-omnivore-anchor-idx="708" class="hljs-keyword">the</span> performance dropped tremendously. 

I mean, <span data-omnivore-anchor-idx="709" class="hljs-keyword">it</span> was more <span data-omnivore-anchor-idx="710" class="hljs-keyword">of</span> a micro benchmark, <span data-omnivore-anchor-idx="711" class="hljs-literal">true</span>, <span data-omnivore-anchor-idx="712" class="hljs-keyword">but</span> still...

Because you are out <span data-omnivore-anchor-idx="713" class="hljs-keyword">on</span> <span data-omnivore-anchor-idx="714" class="hljs-keyword">the</span> contention...

No, wait—<span data-omnivore-anchor-idx="715" class="hljs-keyword">on</span> contention, no, I didn't schedule out!

Well, yes—

Oh, yeah? Okay.

So unless <span data-omnivore-anchor-idx="716" class="hljs-keyword">the</span> other... Well, maybe slightly valid point, <span data-omnivore-anchor-idx="717" class="hljs-keyword">but</span> whenever talking <span data-omnivore-anchor-idx="718" class="hljs-keyword">about</span> overhead, <span data-omnivore-anchor-idx="719" class="hljs-keyword">it</span>’s always good <span data-omnivore-anchor-idx="720" class="hljs-keyword">to</span> be aware <span data-omnivore-anchor-idx="721" class="hljs-keyword">of</span> like DVFS impact <span data-omnivore-anchor-idx="722" class="hljs-keyword">and</span> all <span data-omnivore-anchor-idx="723" class="hljs-keyword">the</span> power management <span data-omnivore-anchor-idx="724" class="hljs-keyword">and</span> like, are you accidentally <span data-omnivore-anchor-idx="725" class="hljs-built_in">running</span> slightly faster when you measure <span data-omnivore-anchor-idx="726" class="hljs-keyword">the</span> overhead? 

I don’t know; I’ve seen enough <span data-omnivore-anchor-idx="727" class="hljs-keyword">of</span> these overheads sometimes being wrongly attributed, which might <span data-omnivore-anchor-idx="728" class="hljs-keyword">not</span> be <span data-omnivore-anchor-idx="729" class="hljs-keyword">the</span> case <span data-omnivore-anchor-idx="730" class="hljs-keyword">over</span> here. But <span data-omnivore-anchor-idx="731" class="hljs-keyword">at</span> least when talking <span data-omnivore-anchor-idx="732" class="hljs-keyword">with</span> app developers, they <span data-omnivore-anchor-idx="733" class="hljs-keyword">try</span> <span data-omnivore-anchor-idx="734" class="hljs-keyword">to</span>... <span data-omnivore-anchor-idx="735" class="hljs-keyword">and</span> like, “Yeah, you’re <span data-omnivore-anchor-idx="736" class="hljs-built_in">running</span> a little bit slower—<span data-omnivore-anchor-idx="737" class="hljs-keyword">that</span>’s why,” <span data-omnivore-anchor-idx="738" class="hljs-keyword">and</span> you need <span data-omnivore-anchor-idx="739" class="hljs-keyword">to</span> basically mitigate <span data-omnivore-anchor-idx="740" class="hljs-keyword">it</span> differently.

Anything <span data-omnivore-anchor-idx="741" class="hljs-keyword">else</span>? 

I’ll <span data-omnivore-anchor-idx="742" class="hljs-keyword">put</span> <span data-omnivore-anchor-idx="743" class="hljs-keyword">in</span> an action <span data-omnivore-anchor-idx="744" class="hljs-built_in">item</span> <span data-omnivore-anchor-idx="745" class="hljs-keyword">for</span> myself: I will implement <span data-omnivore-anchor-idx="746" class="hljs-keyword">the</span> fch spinner, like adaptive spinning, <span data-omnivore-anchor-idx="747" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="748" class="hljs-keyword">then</span> I’ll <span data-omnivore-anchor-idx="749" class="hljs-built_in">run</span> <span data-omnivore-anchor-idx="750" class="hljs-keyword">the</span> same test <span data-omnivore-anchor-idx="751" class="hljs-keyword">to</span> make sure <span data-omnivore-anchor-idx="752" class="hljs-keyword">and</span> test <span data-omnivore-anchor-idx="753" class="hljs-keyword">to</span> make sure <span data-omnivore-anchor-idx="754" class="hljs-keyword">it</span>’s <span data-omnivore-anchor-idx="755" class="hljs-keyword">not</span> actually scheduling.

So I’ll add <span data-omnivore-anchor-idx="756" class="hljs-keyword">that</span>—<span data-omnivore-anchor-idx="757" class="hljs-keyword">it</span> would be nice.

I actually implemented <span data-omnivore-anchor-idx="758" class="hljs-keyword">some</span> kind <span data-omnivore-anchor-idx="759" class="hljs-keyword">of</span> optimistic spinning <span data-omnivore-anchor-idx="760" class="hljs-keyword">for</span> futex <span data-omnivore-anchor-idx="761" class="hljs-keyword">before</span>, <span data-omnivore-anchor-idx="762" class="hljs-keyword">and</span> I sent out a patch, <span data-omnivore-anchor-idx="763" class="hljs-keyword">but</span> <span data-omnivore-anchor-idx="764" class="hljs-keyword">the</span> problem <span data-omnivore-anchor-idx="765" class="hljs-keyword">is</span> there are no user applications, so you didn’t <span data-omnivore-anchor-idx="766" class="hljs-keyword">get</span>...

Yeah, oh, I think one <span data-omnivore-anchor-idx="767" class="hljs-keyword">of</span> <span data-omnivore-anchor-idx="768" class="hljs-keyword">the</span> problems <span data-omnivore-anchor-idx="769" class="hljs-keyword">is</span> also we don’t know who <span data-omnivore-anchor-idx="770" class="hljs-keyword">the</span> owner <span data-omnivore-anchor-idx="771" class="hljs-keyword">is</span>.

That’s <span data-omnivore-anchor-idx="772" class="hljs-literal">true</span>.

They have <span data-omnivore-anchor-idx="773" class="hljs-keyword">to</span> pass—all this works only <span data-omnivore-anchor-idx="774" class="hljs-keyword">with</span> robust futexes anyway because you have <span data-omnivore-anchor-idx="775" class="hljs-keyword">to</span> know who <span data-omnivore-anchor-idx="776" class="hljs-keyword">the</span> owner <span data-omnivore-anchor-idx="777" class="hljs-keyword">is</span>. 

So you have <span data-omnivore-anchor-idx="778" class="hljs-keyword">the</span> TID <span data-omnivore-anchor-idx="779" class="hljs-keyword">in</span> <span data-omnivore-anchor-idx="780" class="hljs-keyword">the</span> futex field itself, <span data-omnivore-anchor-idx="781" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="782" class="hljs-keyword">it</span>’s handed <span data-omnivore-anchor-idx="783" class="hljs-keyword">in</span> via <span data-omnivore-anchor-idx="784" class="hljs-keyword">the</span> syscall anyway, so <span data-omnivore-anchor-idx="785" class="hljs-keyword">it</span>’s low overhead <span data-omnivore-anchor-idx="786" class="hljs-keyword">from</span> figuring out who <span data-omnivore-anchor-idx="787" class="hljs-keyword">the</span> owner <span data-omnivore-anchor-idx="788" class="hljs-keyword">is</span>. 

Then you can do <span data-omnivore-anchor-idx="789" class="hljs-keyword">the</span> lookup <span data-omnivore-anchor-idx="790" class="hljs-keyword">in</span> <span data-omnivore-anchor-idx="791" class="hljs-keyword">the</span> kernel, <span data-omnivore-anchor-idx="792" class="hljs-keyword">and</span> <span data-omnivore-anchor-idx="793" class="hljs-keyword">it</span>’s all there—<span data-omnivore-anchor-idx="794" class="hljs-keyword">it</span>'s all existing code, so <span data-omnivore-anchor-idx="795" class="hljs-keyword">it</span> shouldn’t be hard <span data-omnivore-anchor-idx="796" class="hljs-keyword">to</span> hack up. I mean, <span data-omnivore-anchor-idx="797" class="hljs-keyword">if</span> people insist <span data-omnivore-anchor-idx="798" class="hljs-keyword">on</span> using non-robust futexes, I can’t help them.

Anyway, one minute—anyone <span data-omnivore-anchor-idx="799" class="hljs-keyword">else</span>? 

Last minute? 

That’s all we have. 

Okay, thank you!
</code></pre></div></article>
      </div></DIV></DIV>



# links
[Read on Omnivore](https://omnivore.app/me/https-www-youtube-com-watch-v-h-rv-8-s-w-6-k-dc-19195c4dfc7)
[Read Original](https://www.youtube.com/watch?v=hRV8sW6_kDc)

<iframe src="https://www.youtube.com/watch?v=hRV8sW6_kDc"  width="800" height="500"></iframe>
