---
id: aaf2347f-16f5-4589-a18a-63abbc4d6ca4
title: Configuring and Managing Core Dumps in Linux | Baeldung on Linux
author: Baeldung on Linux
tags:
  - linux
  - tools_to_use
date: 2024-01-10 04:20:28
date_published: 2020-07-25 20:34:28
words_count: 1814
state: INBOX
---

# Configuring and Managing Core Dumps in Linux | Baeldung on Linux by Baeldung on Linux
## Table of contents
```dataviewjs 
dv.view('/Bins/js/toc', 1) 
```


## description
>[!summary] 
> Learn how to manage and configure core dumps. We'll investigate kernel.core_pattern and coredumpctl.


# content
```dataviewjs 
dv.view('/Bins/js/remove_html',  ["# content",  "# links"] ) 
```
## 1\. Overview

In this tutorial, we’re going to see how to manage and configure [core](https://man7.org/linux/man-pages/man5/core.5.html) dumps. We’ll investigate _kernel.core\_pattern_ and then we’ll move onto using _coredumpctl_.

## 2\. Introduction

A core dump is a file that gets automatically generated by the Linux kernel after a program crashes. This file contains the **memory, register values, and the call stack of an application at the point of crashing**.

## 3\. Using Signals to Generate a Core Dump

In this section, we’ll learn how to terminate a program and force it to produce a core dump. For this, we’ll use the [_kill_](https://man7.org/linux/man-pages/man1/kill.1.html) command which [uses signals](https://www.baeldung.com/linux/kill-commands) to terminate an application. These signals produce core dumps.

If we look at the table provided by the man page of [_signal,_](https://man7.org/linux/man-pages/man7/signal.7.html) **we can see a list of signals which terminate the programs with a core dump**. **These are signals that have an _Action_ identified with _Core_**:

       Signal      Standard   Action   Comment
       ────────────────────────────────────────────────────────────────────────
       SIGABRT      P1990      Core    Abort signal from abort(3)
       SIGALRM      P1990      Term    Timer signal from alarm(2)

As an example, let’s use [_sleep_](https://man7.org/linux/man-pages/man1/sleep.1.html) as a program that runs indefinitely:

```gams
$ sleep 500
[1] 5464
$ kill -s SIGTRAP $(pgrep sleep)
[1]+  Trace/breakpoint trap (core dumped) sleep 500
```

We can see the message of **“core dumped” indicates a successful core dump**. We also notice **“Trace/breakpoint trap” which indicates the signal of _SIGTRAP_**.

Now that we have this framework in place, let’s see how core dumps are configured.

## 4\. Configuring Core Dumps

There are two ways to configure a core dump. One is passing the core dump via a pipe, and the other is storing it in a file.

**The main configuration parameter is _kernel.core\_pattern_**. This is applicable for both file and pipe-based core dumps. In addition to this configuration parameter, **file-based dumps have a size restriction on them**. We can configure this size using _[ulimit](https://ss64.com/bash/ulimit.html)._

We’ll cover both configuration types in the following sections.

### 4.1\. Redirect a Core Dump to a Pipe

Let’s see how to configure our system to produce a core dump via a pipe. First, we need an example program to extract the core dump from the pipe. After that, we’ll configure the kernel to provide the program name as an argument and core dump to our program.

Let’s write a program which will only produce a core dump if the crashing process is _sleep_:

```livecodeserver
#!/usr/bin/python2.7
# Filename: /tmp/core_dump_example.py
import sys

# Expect sys.argv to have %e configured in kernel.core_pattern
process_filename = sys.argv[1]

if process_filename == "sleep":
    with open("/tmp/sleep_core_dump", "wb") as core_dump:
        core_contents = bytearray(sys.stdin.read())
        core_dump.write(core_contents)
```

Here, we notice that the program checks the first argument and only outputs a core dump if it contains _sleep_. Let’s store this under _/tmp/core\_dump\_example.py_ and give it executable permission.

**Now, we’d like the OS to invoke our script whenever it’s producing a core dump**. By reading the man page for [core](https://man7.org/linux/man-pages/man5/core.5.html), we can achieve this by configuring the _kernel.core\_patttern_ property with _[sysctl](https://man7.org/linux/man-pages/man8/sysctl.8.html)_:

```elixir
$ sudo sysctl -w kernel.core_pattern="|/tmp/core_dump_example.py %e"
```

The pipe at the beginning of the pattern indicates that the OS should pass the contents of the core dump to our script over stdin.

Notice the _%e_ at the end. **_%e_ is a template that expands to the process name of the crashed application**. There are many more templates available, described in the [core](https://man7.org/linux/man-pages/man5/core.5.html) man page.

Let’s try creating a core dump:

```gams
$ sleep 500 &
[1] 8828
$ kill -s SIGTRAP $(pgrep sleep)
[1]+  Trace/breakpoint trap (core dumped) sleep 500
```

Let’s check the signature of the file we’ve created using our python script:

```groovy
$ file /tmp/sleep_core_dump
/tmp/sleep_core_dump: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from 'sleep 500', real uid: 1000, effective uid: 1000, real gid: 1000, effective gid: 1000, execfn: '/usr/bin/sleep', platform: 'x86_64'
```

By using _[file](https://linux.die.net/man/1/file) on the core dump_, we can immediately see that the crashing program is _/usr/bin/sleep._ It also shows us with other information such as the UID which started this process.

### 4.2\. Redirect a Core Dump to a File

Following, let’s **configure our system to produce a core dump file. To do this,** **we set _kernel.core\_pattern_ to our desired filename**. Using the templates found in the [core](https://man7.org/linux/man-pages/man5/core.5.html) man page, we can decorate the core dump filename.

First, let’s set our core dump filename:

```perl
$ sudo sysctl -w kernel.core_pattern="/tmp/%e_core_dump.%p"
```

When the _sleep_ application crashes, we would expect a file with the pattern of _sleep\_core\_dump.pid_ to appear under _/tmp_. Where _%e_ is the program name and _%p_ is the program’s PID.

Note that instead of an absolute path, we could give a filename. This would create a core dump file in the current working directory of the crashing process.

Next, we need to check any limits imposed using [_ulimit_](https://ss64.com/bash/ulimit.html). **Core dump files have a limit set by default**. **These limits set by _ulimit_ do not affect the pipe-based core dump handlers**.

The unit of the core dump size is in _blocks_. Let’s find out how many bytes there are per block:

```shell
$ stat -fc %s .
4096

```

Using the _4096 bytes per block_, let’s set our limit to 5 MB as we don’t expect the examples to generate core dumps greater than 5 MB. This can be calculated as _nblocks = desired\_limit / block\_size_ where both desired\_limit and block\_size are in bytes. 5 MB is equivalent to 1280 blocks = (5 \* 1024 \* 1024) / 4096.

A core dump has a hard limit set to _0_ by default. To set up the limits we have to add the following two lines to _[/etc/security/limits.conf](https://linux.die.net/man/5/limits.conf)_:

```angelscript
baeldung_user hard core 1280
baeldung_user soft core 1280
```

**Hard limits are system-wide limits and soft limits are user-based limits**. A soft limit should be less than their corresponding hard limit. We’ll need to reboot after this.

Let’s check the size limit of core dump files after a reboot:

```shell
$ ulimit -c
1280
```

Great, that has taken effect. Let’s try to create a core dump:

```gams
$ sleep 500 &
[1] 9183
$ kill -s SIGTRAP $(pgrep sleep)
[1]+  Trace/breakpoint trap (core dumped) sleep 500
$ ls /tmp/*_core_*
-rw------- 1 user user 372K Jun 26 23:31 /tmp/sleep_core_dump.1780
```

We’ve created a core dump file with the desired pattern.

## 5\. Generating Core Dumps for Running Processes

Sometimes it might be useful to generate a core dump for a running process. [GDB](https://www.gnu.org/software/gdb/documentation/) can capture core dumps of a running process, but it also comes with a utility called _[gcore](https://man7.org/linux/man-pages/man1/gcore.1.html)_. **_gcore_ is a command-line utility that can capture the core dump of a running process.**

Let’s try capturing a core dump using _gcore_:

```angelscript
$ sleep 500 &
[1] 3000
$ sudo gcore -o sleep 3000
0x00007f975eee630e in clock_nanosleep () from /lib/x86_64-linux-gnu/libc.so.6
warning: target file /proc/3000/cmdline contained unexpected null characters
warning: Memory read failed for corefile section, 4096 bytes at 0xffffffffff600000.
Saved corefile sleep.3000
[Inferior 1 (process 3000) detached]
```

We can see that a _sleep_ process was started with a PID of 3000\. Afterward, _gcore_ was launched and attached itself to the _sleep_ process. As a result, _gcore_ then produced a core dump file of _sleep.3000_ and detached itself. **After _gcore_ has detached itself from a process, a process will happily continue running unaffected.**

Note: _gcore_ requires _sudo_ to attach to a process. We could set _kernel.yama.ptrace\_scope_ to _0_ using _sysctl_. This would allow _gcore_ to attach to a process without _sudo_. However, be warned that this should be used with caution as it’s a security risk. Any process would be able to use the _[ptrace](https://man7.org/linux/man-pages/man2/ptrace.2.html)_ system call and examine any programs internals.

## 6\. Introduction to _coredumpctl_

In this section, we’ll introduce a utility called [_coredumpctl_](https://manpages.debian.org/stretch/systemd-coredump/coredumpctl.1.en.html). In contrast to manually configuring a core dump, _coredumpctl_ automatically manages core dumps. **_coredumpctl_ records the core dumps themselves and maintains a history of crashes.**

In the following sections, we’ll assume that _coredumpctl_ is already installed on the system.

## 6.1\. Configuring _coredumpctl_

_coredumpctl_ comes with a service called **_[systemd-coredump](https://www.freedesktop.org/software/systemd/man/systemd-coredump.html)_**_._ **This is a service that acquires the core dump, then processes it to extract metadata out of it.** It then stores this information under _/var/lib/systemd/coredump/._

We can check whether or not this service is configured by checking the _kernel.core\_pattern_:

```cos
$ sysctl -n kernel.core_pattern
|/lib/systemd/systemd-coredump %P %u %g %s %t 9223372036854775808 %h
```

We’ve confirmed that **_kernel.core\_pattern_ is set to use _systemd-coredump_.** **This tells the kernel to pass any information related to core dumps to _systemd-coredump_.**

To try _coredumpctl,_ we first we need to generate a new core dump:

```angelscript
$ sleep 500 &
[1] 2826
$ kill -s SIGTRAP $(pgrep sleep)
[1]+  Trace/breakpoint trap (core dumped) sleep 500
$ coredumpctl
TIME                            PID   UID   GID SIG COREFILE  EXE
Sun 2020-06-28 18:52:59 BST    2826  1000  1000   5 present   /usr/bin/sleep
```

This is really cool. By trying out _coredumpctl_ we can see that we have a history of crashes!

**To extract a core dump file for a specific crash we can use either** **a PID, the name of executable, or time of the crash**. As an example, let’s attempt to save the core dump of _sleep_ using a PID:

```angelscript
$ coredumpctl dump 2826 --output=core.dump
           PID: 2826 (sleep)
           UID: 1000 (user)
           ...
                Stack trace of thread 2826:
                #0  0x00007f7ec62f730e __GI___clock_nanosleep (libc.so.6 + 0xe030e)
                #1  0x00007f7ec62fceb7 __GI___nanosleep (libc.so.6 + 0xe5eb7)
           ...
```

In addition to the core dump file, we can see a short summary followed by a stack trace. This comes from the pre-processing of the core dump by _systemd-coredump_.

### 6.3\. Running a Debug Session With _coredumpctl_

Let’s see how **we can launch a debugging session by using the _debug_ command**:

```gauss
$ coredumpctl debug 2826
...
Reading symbols from /usr/bin/sleep...
(No debugging symbols found in /usr/bin/sleep)
[New LWP 2959]
Core was generated by `sleep 500'.
Program terminated with signal SIGTRAP, Trace/breakpoint trap.
...
(gdb)
```

Notice how _gdb_ was opened automatically with the core dump file loaded.

To inspect the crash, let’s type in “disassemble”. As a result, we can see the following disassembly:

```excel
Dump of assembler code for function __GI___clock_nanosleep:
<__GI___clock_nanosleep+80>
   0x00007fb71b22c307 <+39>:    mov    eax,0xe6
   0x00007fb71b22c30c <+44>:    syscall
=> 0x00007fb71b22c30e <+46>:    mov    edx,eax
```

We can see, there’s “_mov wax, 0xe6″_ followed by a _syscall_ instruction. Looking at the list of _[syscalls](https://filippo.io/linux-syscall-table/)_, it seems that 230 (0xe6) is the _clock\_nanosleep_ _syscall_. This is the point where the core dump was captured.

## 7\. Conclusion

In this tutorial, we’ve explored how to configure core dumps. Later on, we explored the utility _coredumpctl,_ which makes it much easier to manage core dumps.

Comments are closed on this article!



# links
[Read on Omnivore](https://omnivore.app/me/configuring-and-managing-core-dumps-in-linux-baeldung-on-linux-18cf12bb86a)
[Read Original](https://www.baeldung.com/linux/managing-core-dumps)

<iframe src="https://www.baeldung.com/linux/managing-core-dumps"  width="800" height="500"></iframe>
